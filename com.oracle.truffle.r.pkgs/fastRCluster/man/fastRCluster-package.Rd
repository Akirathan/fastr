% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fastRCluster.R
\docType{package}
\name{fastRCluster-package}
\alias{fastRCluster}
\alias{fastRCluster-package}
\title{Run your R code faster with FastR!}
\description{
FastR is an alternative implementation of the R programming language,
which provides superb performance for computation intensive longer
running jobs, but takes bit more time to warm-up. The performance
of FastR is especially good with pure R code with loops, but it can
also deal with C/C++/Fortran code in R packages.

Package \emph{fastRCluster} lets you run FastR inside GNU-R via PSOCK cluster. 
With this package, you can move your performance critical R algorithms to FastR,
but keep the rest of your code-base on GNU-R. You can also use this package
to gradually move all your code to FastR.

We recommend using fastRCluster as a back-end for the \emph{future} package.
Keep your configuration of the \emph{future} package isolated from the rest
of the system to be able to simply switch between FastR and other back-ends.
}
\details{
This package does not come with pre-installed FastR. However, FastR can be
installed using the \code{installFastR} function. Once FastR is installed,
you can create cluster nodes that delegate to FastR using \code{makeFastRCluster}.
Note: like with PSOCK cluster, you have to install required packages on the FastR engine.
You can use \code{fastRClusterInstallPackages} to install the necessary packages.

FastR leverages dynamic just-in-time compilation. R functions are first interpreted
and then compiled. The first few executions are much slower. In order to re-use
the compiled code as much as possible, it is good idea to first transfer all the
necessary R functions to the cluster nodes using \code{clusterExport}.
If you send large and computation heavy R function via, e.g., \code{clusterApply},
it will be always deserialized to a different function on the other end in FastR and hence
no compiled code will be reused.
}
\examples{
library(fastRCluster)

# downloads and installs FastR, note: this may take a while
installFastR()

# use the cluster package with FastR
fastrNode <- makeFastRCluster()
print(fastrNode)
# prints: FastR socket cluster with 1 nodes on host ‘localhost’

# install required packages on FastR
fastRClusterInstallPackages('rlang')

# use the cluster package with FastR
# R.version will show that we are running that code on FastR
parallel::clusterApply(fastrNode, 'dummy', function(...) R.version)

# use 'fastr' convenient wrapper around clusterApply
gg <- fastr(fastrNode, ggplot2::qplot(mpg, data=mtcars, geom="density",
  main=paste0("Generated by ", R.version$engine, "[", Sys.getpid(), "]")))
plot(gg)

# transfer data and a helper function to the global environmnet of the cluster nodes
largeDataSet <- matrix(runif(1000000), 1000, 1000)
myComputation <- function(x) {
  x <- x/sum(x)
  res <- 0
  colsums <- colSums(x)
  rowsums <- rowSums(x)
  for(i in seq_along(1:nrow(x))){
    for(j in seq_along(1:ncol(x))){
      temp <- log((x[i,j]/(colsums[j]*rowsums[i])))
      res <- res + x[i,j] * if(is.finite(temp)) temp else 0
    }
  }
  res
}
parallel::clusterExport(fastrNode, c('largeDataSet', 'myComputation'))
# now you can refer to 'largeDataSet' and 'myComputation'
fastr(fastrNode, myComputation(largeDataSet))

# use the future package with FastR
if (require(future)) {
  future::plan(future::cluster, workers = makeFastRCluster())
  val \%<-\% R.version
  print(val)
}

}
\keyword{internal}
